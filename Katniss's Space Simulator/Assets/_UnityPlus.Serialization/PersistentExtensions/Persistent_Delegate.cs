using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading.Tasks;
using UnityPlus.Serialization;

namespace UnityPlus.Serialization
{
    public static class Persistent_Delegate
    {
        /// <remarks>
        /// This is capable of fully serializing an arbitrary delegate, including multicasting, lambdas, and references to instance methods. <br />
        /// 2. CHANGING CODE MIGHT INVALIDATE REFERENCES TO LAMBDAS (because the autogenerated method names might be different).
        /// </remarks>
        [MethodImpl( MethodImplOptions.AggressiveInlining )]
        public static SerializedData GetData( this Delegate delegateObj, IReverseReferenceMap s )
        {
            if( delegateObj == null )
                return null;

            SerializedArray invocationListJson = new SerializedArray();

            foreach( var del in delegateObj.GetInvocationList() )
            {
                SerializedData delJson = WriteSingleDelegate( del, s );
                invocationListJson.Add( delJson );
            }

            return invocationListJson;
        }

        [MethodImpl( MethodImplOptions.AggressiveInlining )]
        private static SerializedData WriteSingleDelegate( Delegate delegateObj, IReverseReferenceMap s )
        {
            Type delegateType = delegateObj.GetType();

            MethodInfo method = delegateObj.Method;
            Type declaringType = method.DeclaringType;
            object target = delegateObj.Target;

            ParameterInfo[] parameters = method.GetParameters();
            SerializedArray serializedParameters = new SerializedArray( parameters.Select( param => param.ParameterType.GetData() ) );
            

            SerializedObject obj = new SerializedObject()
            {
                { "method", new SerializedObject()
                {
                    { "delegate_type", delegateType.GetData() },
                    { "identifier", method.Name.GetData() },
                    { "parameters", serializedParameters },
                    { "declaring_type", declaringType.GetData() }
                } },
                { "target", s.WriteObjectReference( target ) }
            };
            return obj;
        }

        /// <remarks>
        /// This is capable of fully deserializing an arbitrary delegate, including multicasting, lambdas, and references to instance methods. <br />
        /// 1. THE TARGET OBJECT SHOULD BE DESERIALIZED BEFOREHAND. <br />
        /// 2. CHANGING CODE MIGHT INVALIDATE REFERENCES TO LAMBDAS (because the autogenerated method names might be different).
        /// </remarks>
        [MethodImpl( MethodImplOptions.AggressiveInlining )]
        public static Delegate AsDelegate( this SerializedData data, IForwardReferenceMap l )
        {
            if( data == null )
                return null;

            SerializedArray array = (SerializedArray)data;

            if( array.Count == 1 )
            {
                return ReadSingleDelegate( array[0], l );
            }

            IEnumerable<Delegate> invocationList = array.Select( a => ReadSingleDelegate( a, l ) );

            return Delegate.Combine( invocationList.ToArray() );
        }

        [MethodImpl( MethodImplOptions.AggressiveInlining )]
        private static Delegate ReadSingleDelegate( SerializedData data, IForwardReferenceMap l )
        {
            object target = l.ReadObjectReference( data["target"] );

            Type delegateType = data["method"]["delegate_type"].AsType();
            Type declaringType = data["method"]["declaring_type"].AsType();
            IEnumerable<Type> parameters = ((SerializedArray)data["method"]["parameters"]).Select( p => p.AsType() );

            string methodName = data["method"]["identifier"].AsString();

            MethodInfo method = declaringType.GetMethod( methodName, BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic, null, parameters.ToArray(), null );
            Delegate delegateObj = method.CreateDelegate( delegateType, target );

            return delegateObj;
        }
    }
}