using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading.Tasks;
using UnityPlus.AssetManagement;

namespace UnityPlus.Serialization
{
	public static class IForwardReferenceMap_Ex_References
	{
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		public static object ReadObjectReference( this IForwardReferenceMap l, SerializedData data )
		{
			// should only be called in data actions.

			// A missing '$ref' node means the reference couldn't save properly.

			if( ((SerializedObject)data).TryGetValue( KeyNames.REF, out SerializedData refData ) )
			{
				Guid guid = refData.ToGuid();

				return l.GetObj( guid );
			}
			return null;
		}

		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		public static T ReadAssetReference<T>( this IForwardReferenceMap l, SerializedData data ) where T : class
		{
			if( ((SerializedObject)data).TryGetValue( KeyNames.ASSETREF, out SerializedData refData ) )
			{
				string assetID = (string)refData;

				return AssetRegistry.Get<T>( assetID );
			}
			return null;
		}

		/// <summary>
		/// Reads a delegate (reference to a method).
		/// </summary>
		/// <remarks>
		/// This is capable of fully deserializing an arbitrary delegate, including multicasting, lambdas, and references to instance methods. <br />
		/// 1. THE TARGET OBJECT SHOULD BE DESERIALIZED BEFOREHAND. <br />
		/// 2. CHANGING CODE MIGHT INVALIDATE REFERENCES TO LAMBDAS (because the autogenerated method names might be different).
		/// </remarks>
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		public static Delegate ReadDelegate( this IForwardReferenceMap l, SerializedData data )
		{
			if( data == null )
				return null;

			SerializedArray jsonA = (SerializedArray)data;

			if( jsonA.Count == 1 )
			{
				return l.ReadSingleDelegate( jsonA[0] );
			}

			Delegate[] invocationList = new Delegate[jsonA.Count];
			for( int i = 0; i < jsonA.Count; i++ )
			{
				invocationList[i] = l.ReadSingleDelegate( jsonA[i] );
			}
			return Delegate.Combine( invocationList );
		}

		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		private static Delegate ReadSingleDelegate( this IForwardReferenceMap l, SerializedData data )
		{
			// TODO - this requires the target to be already deserialized.
			object target = l.ReadObjectReference( data["Target"] );

			Type delegateType = data["method"]["delegate_type"].ToType();
			Type declaringType = data["method"]["declaring_type"].ToType();
			List<Type> parameters = new List<Type>();
			foreach( var jsonParam in (SerializedArray)data["method"]["parameters"] )
			{
				parameters.Add( jsonParam.ToType() );
			}
			string methodName = (string)data["method"]["identifier"];

			MethodInfo method = declaringType.GetMethod( methodName, parameters.ToArray() );
			Delegate delegateObj = method.CreateDelegate( delegateType, target );

			return delegateObj;
			// returns the delegate object that is ready to be assigned to the field
		}
	}
}